float CloudDensity(float3 P) {
	// Creating smooth-edge mask
	float Mask = smoothstep(1, 0.8, dot(P, P));
	// applying Noise to create a Cloud Base
	float Noise = MaterialExpressionNoise(P, 4, 1, 2, 0, 1, -0.2, 1, 2, 0, 0, 512);
	return Mask * Noise;
}

float4 Cloud(FMaterialPixelParameters Parameters, int MaxSteps, float3 GivenColor) {
	FWSVector3 WorldPos = GetWorldPosition(Parameters);
	FWSVector3 ObjPos = GetObjectWorldPosition(Parameters);
	
	// Scaling radial mask by size of object
	float Size = GetPrimitiveData(Parameters).ObjectBoundsX;
	Size = max(Size, GetPrimitiveData(Parameters).ObjectBoundsY);
	Size = max(Size, GetPrimitiveData(Parameters).ObjectBoundsZ);
	float3 result = WSDemote(WSSubtract(WorldPos, ObjPos)) / Size;
	
	// Implementing March Step (to get a volumetric shader)
	// a unit sphere has diameter of 2 so step sizes need to be twice as big to cover it
	float3 RayStep = -Parameters.CameraVector * (2.0 / MaxSteps);
	// Implement Shadow March (to calculate light from primary source)
	float3 ShadowStep = MaterialExpressionAtmosphericLightVector(Parameters) * (2.0 / MaxSteps);
	
	// Needed to randomly generate where ray is cast to decide shading
	int3 RandPos = int3(GetPixelPosition(Parameters), View.FrameNumber);
	float3 Rand = float3(Rand3DPCG16(RandPos)) / 0x10000;
	result += Rand.x * RayStep;
	
	float4 Color = 0;
	for (int i = 0; i < MaxSteps && dot(result, result) < 1; ++i, result += RayStep) {
		float4 LocalColor = float4(GivenColor, 1) * CloudDensity(result);
		
		// if there is cloud, aka not transparent
		if (LocalColor.a > 0) {
			float3 SP = result + Rand.y * ShadowStep;
			float Shadow = 0;
			for (int j = 0; j < MaxSteps && dot(SP, SP) < 1; ++j, SP += ShadowStep) {
				Shadow += (1 - Shadow) * CloudDensity(SP);
			}
			LocalColor.rgb *= Shadow;
		}
		
		Color += (1 - Color.a) * LocalColor;
	}
	
	//return CloudDensity(result);
	return Color;
}